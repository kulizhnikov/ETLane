fastlane_version "2.68.2"

default_platform :ios

platform :ios do

  product_bundle_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
  distribute_group_name = ENV["DISTRIBUTE_GROUP_NAME"]
  project_name = ENV["PROJECT_NAME"]
  extension_bundle_ids = ENV["EXTENSION_BUNDLE_IDS"].split(",")
  build_folder = File.join(Dir.pwd, "..", "build")
  last_commit_path = File.join(Dir.pwd, "last_commit")
  scripts_dir = File.join(Dir.pwd, "../Pods/ETLane/Scripts")

  desc "Push a new beta build to TestFlight"
  lane :beta do |options|
    skip_processing = false #UI.select("Skip waiting for build upload to TestFlight?: ", [true, false])
    provisioning_profile = "AppStore_#{product_bundle_identifier}"
    username = options[:username]

    get_certificates(output_path: build_folder, username: username)
    profile_uuid = get_provisioning_profile(output_path: build_folder, username: username, app_identifier: product_bundle_identifier)
    provisioningProfiles = Hash.new
    provisioningProfiles[product_bundle_identifier] = profile_uuid
    for extension_bundle_id in extension_bundle_ids do
      extension_bundle_identifier = "#{product_bundle_identifier}.#{extension_bundle_id}"
      extension_profile_uuid = get_provisioning_profile(output_path: build_folder, username: username, app_identifier: extension_bundle_identifier)
      provisioningProfiles[extension_bundle_identifier] = extension_profile_uuid
    end

    team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id)
    build_app(
      workspace: "#{project_name}.xcworkspace", 
      export_xcargs: "PROVISIONING_PROFILE_SPECIFIER='#{provisioning_profile}' DEVELOPMENT_TEAM='#{team_id}' CODE_SIGN_STYLE='Manual'",
      scheme: project_name,
      output_directory: build_folder,
      include_bitcode: false,
      skip_profile_detection: false,
        export_options: {
          method: "app-store",
          signingStyle: "manual",
          provisioningProfiles: provisioningProfiles
      },
    )
    last_commit = File.read(last_commit_path)
    changelog = changelog_from_git_commits(
      quiet: true,
      between: [last_commit, "HEAD"],  # Optional, lets you specify a revision/tag range between which to collect commit info
      pretty: "– %s",# Optional, lets you provide a custom format to apply to each commit when generating the changelog text
      date_format: "short",# Optional, lets you provide an additional date format to dates within the pretty-formatted string
      match_lightweight_tag: false,  # Optional, lets you ignore lightweight (non-annotated) tags when searching for the last tag
      merge_commit_filtering: "exclude_merges" # Optional, lets you filter out merge commits
    )
    puts changelog
    version = get_version_number(target: project_name) + " (" + get_build_number() + ")"
    increment_and_push()
    ENV["FL_CHANGELOG"] = nil

    beta_app_review_info = {}
    if ENV["ET_BETA_APP_REVIEW_INFO"]
      beta_app_review_info = eval(ENV["ET_BETA_APP_REVIEW_INFO"])
    end

    upload_to_testflight(
      skip_waiting_for_build_processing: skip_processing, 
      username: username,
      beta_app_review_info: beta_app_review_info,
      distribute_external: true,
      changelog: "",
      groups: ["#{distribute_group_name}"]
    )
    notify_changes(changelog: changelog, version: version)
  end

  lane :metadata do |options|
    username = options[:username]
    skip_screenshots = options[:skip_screenshots] != nil ? options[:skip_screenshots] : false
    skip_preview = options[:skip_preview] != nil ? options[:skip_preview] : true
    download_preview = options[:download_preview] != nil ? options[:download_preview] : false
    skip_metadata = options[:skip_metadata] != nil ? options[:skip_metadata] : false
    google_sheet_tsv = ENV["GOOGLE_SHEET_TSV"]

    metadata_path = File.join(build_folder, "metadata")
    FileUtils.rm_rf(metadata_path)
    screenshots_path = File.join(build_folder, "screenshots")
    preview_path = File.join(build_folder, "previews")
    if !skip_screenshots
      FileUtils.rm_rf(screenshots_path)
    end

    cocoapods(
      try_repo_update_on_error: true,
      use_bundle_exec: true,
    )

    if download_preview
      FileUtils.rm_rf(preview_path)
    end
    
    Dir.chdir(scripts_dir) do
      sh(
        "swift", "run", "Performance", 
        google_sheet_tsv,
        "--output=#{build_folder}",
        "--skip_screenshots=#{skip_screenshots}",
        "--download_preview=#{download_preview}"
      )
    end
    deliver(
      username: username,
      submit_for_review: false,
      ignore_language_directory_validation: true,
      force: true,
      # edit_live: true,
      skip_binary_upload: true,
      skip_screenshots: skip_screenshots,
      skip_metadata: skip_metadata,
      screenshots_path: screenshots_path,
      metadata_path: metadata_path,
      overwrite_screenshots: true
    )

    if !skip_preview
      fastlane_require 'spaceship'
      Spaceship.login
      spaceship = Spaceship::Tunes.login(options[:username])
      spaceship.team_id = CredentialsManager::AppfileConfig.try_fetch_value(:itc_team_id)
      product_bundle_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
      app = Spaceship::Tunes::Application.find(product_bundle_identifier)
      app_version = app.edit_version()
      dirs = []
      Dir.chdir(preview_path) do
      dirs = Dir.glob(File.join(preview_path, "*")).select { |f| File.directory?(f) }
      end
      dirs = Dir.entries(preview_path).select { |f| not File.directory?(f) and f != '.DS_Store' }
      for locale in dirs do
        locale_path = File.join(preview_path, locale)
        timestamp = "00.10"
        locale_files = Dir.entries(locale_path).select {|f| not File.directory?(f) }
        puts locale_files
        for file in locale_files do
          if file == "timestamp.txt"
            timestamp = File.read(File.join(locale_path, file))
          end
        end

        for file in locale_files do
          video_path = File.join(locale_path, file)
          if File.extname(file).downcase == ".mp4"
            size = File.size(video_path)
            if size > 500000
              file_name = file.split('.')[0] 
              puts "Upload: #{video_path}"
              upload = app_version.upload_trailer!(video_path, 1, locale, file_name, timestamp)              
            else
              puts "#{video_path} too small, #{size}b"
            end
          end
        end
      end
    end
  end

  lane :notify_changes do |options|
    changelog = options[:changelog]
    if changelog
      version = options[:version] ? options[:version] : get_version_number(target: project_name) + " (" + get_build_number() + ")"
      # Сохраним текущий комит
      File.write(last_commit_path, last_git_commit[:commit_hash])
      git_add(path: last_commit_path)
      commit_bump(message: "Freeze changelog")
      push_to_git_remote
      slack(
        message: "App successfully uploaded to TestFlight.",
        success: true,
        default_payloads: [],
        attachment_properties: {
          fields: [ 
            {
              title: "Build number",
              value: version,
            },
            {
              title: "Changelog",
              value: changelog,
            },
          ]
        }
      )
    end
  end

  # fastlane action new_version bump_type:patch|minor|major
  lane :new_version do |options|
    bump_type = options[:bump_type] ? options[:bump_type] : "patch"
    increment_and_push(bump_type: bump_type)
  end

  lane :increment_and_push do |options|
    increment_build_number
    bump_type = options[:bump_type]
    if bump_type
      increment_version_number(
        bump_type: bump_type
      )
    end
    commit_bump(message: "Bump up version")
    push_to_git_remote
  end

  lane :commit_bump do |options|
    commit_version_bump(
      message: options[:message], 
      force: true,
      xcodeproj: "#{project_name}.xcodeproj"
    )
  end

  lane :add_group_to_tf_build do |options|
    fastlane_require 'spaceship'

    spaceship = Spaceship::Tunes.login(options[:username])
    spaceship.team_id = fastlane_itc_team_id
    app = Spaceship::Tunes::Application.find(product_bundle_identifier)
    build = Spaceship::TestFlight::Build.latest(app_id: app.apple_id, platform: 'ios')
    group = Spaceship::TestFlight::Group.find(app_id: app.apple_id, group_name: distribute_group_name)
    build.add_group!(group)
    # Find team id
    # teamInfo = spaceship.teams.select { |team| team['contentProvider']['name'].strip.downcase == team_name.strip.downcase }.first
    # team_id = teamInfo['contentProvider']['contentProviderId'] if teamInfo
  end

  # Получить полный список всех team_id & itc_team_id нужные для Appfile
  lane :first_time do |options|
    require "spaceship" 
    applePassword = options[:password]
    apple_id = options[:username] ? username = options[:username] : CredentialsManager::AppfileConfig.try_fetch_value(:apple_id)
    clientTunes = Spaceship::Tunes.login(apple_id, applePassword)
    client = Spaceship::Portal.login(apple_id, applePassword)

    strClientTunes = "" 
    clientTunes.teams.each do |team|
        UI.message "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})"
        strClientTunes << "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})||"
    end 
    puts "ItunesTeamNames: #{strClientTunes[0..-3]}"

    strDevPortal = "" 
    client.teams.each do |team|
        UI.message "#{team['name']} (#{team['teamId']})"
        strDevPortal << "#{team['name']} (#{team['teamId']})||"
    end
    puts "DevTeamNames: #{strDevPortal[0..-3]}"
  end

end
